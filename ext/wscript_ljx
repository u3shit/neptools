# -*- mode: python -*-

def options(ctx):
    ctx.add_option('--host-lua', action='store', default=None,
                   help='System lua 5.1/5.2 + bitop or luajit or ljx')
    ctx.load('gas')

def configure(ctx):
    variant = ctx.variant
    host_variant = variant + '_host'
    if ctx.options.host_lua:
        ctx.find_program(ctx.options.host_lua,
                         var='LUA',
                         environ={'PATH': ctx.environ['PATH']})
    else:
        ctx.setenv(variant + '_host')
        ctx.check_cc(lib='m', mandatory=False)
        # ctx.setenv(variant) # restored by configure_ljx

    if ctx.env.CROSS:
        configure_ljx(ctx, host_variant, host_variant, '_HOST')
    configure_ljx(ctx, variant, host_variant, '')

    ctx.setenv(variant)
    host_env = ctx.all_envs[host_variant]
    ctx.env.LJX_CROSS = ctx.env.CROSS and \
                        ctx.env.DASM_ARCH != host_env.DASM_ARCH or \
                        ctx.env.DASM_DEFINES != host_env.DASM_DEFINES or \
                        host_env.CFLAGS_BUILDVM != host_env.CFLAGS_BUILDVM_HOST or \
                        host_env.DEFINES_BUILDVM != host_env.DEFINES_BUILDVM_HOST
    ctx.msg('Checking if cross compiling ljx',
            ctx.env.LJX_CROSS and 'yes' or 'no',
            color = ctx.env.LJX_CROSS and 'GREEN' or 'YELLOW')

def configure_ljx(ctx, variant, host_variant, suf):
    ctx.setenv(variant)

    if ctx.env['COMPILER_CXX'] != 'msvc':
        ctx.load('gas')

    if ctx.env.DEST_OS == 'linux':
        ctx.check_cc(lib='dl')
        ctx.check_cc(lib='readline')
    ctx.check_cc(lib='m', mandatory=False)

    # preprocess lj_arch.h
    ctx.start_msg('Checking for ljx config')
    cmd = [] # python, why u no have Array#flatten?
    cmd += ctx.env.CC
    cmd += ctx.env.CPPFLAGS
    cmd += ctx.env.CFLAGS
    cmd += ['-E', ctx.path.find_node('ljx/src/lj_arch.h').abspath() ]
    if ctx.env['COMPILER_CXX'] == 'msvc': cmd += ['-Xclang', '-dM']
    else: cmd += ['-dM']
    try:
        out = ctx.cmd_and_log(cmd)
    except Exception:
        ctx.end_msg(False)
        raise

    import re
    reg = re.compile('^#define ([^ ]+) (.*)$')
    macros = dict(map(lambda l: reg.match(l).groups(), out.splitlines()))

    # dasm defines/arch
    dasm_defs = [
        'P'+macros['LJ_ARCH_BITS'],
        'VER='+macros.get('LJ_ARCH_VERSION', ''),
    ]
    if macros.get('LJ_LE', 0) == '1':             dasm_defs += ['ENDIAN_LE']
    else:                                         dasm_defs += ['ENDIAN_BE']
    if macros.get('LJ_HASJIT', 0) == '1':         dasm_defs += ['JIT']
    if macros.get('LJ_HASFFI', 0) == '1':         dasm_defs += ['FFI']
    if macros.get('LJ_DUALNUM', 0) == '1':        dasm_defs += ['DUALNUM']
    if macros.get('LJ_ARCH_HASFPU', 0) == '1':    dasm_defs += ['FPU']
    if macros.get('LJ_ABI_SOFTFP', 0) != '1':     dasm_defs += ['HFABI']
    if macros.get('LJ_NO_UNWIND', 0) == '1':      dasm_defs += ['NO_UNWIND']
    if macros.get('LJ_ARCH_SQRT', 0) == '1':      dasm_defs += ['SQRT']
    if macros.get('LJ_ARCH_ROUND', 0) == '1':     dasm_defs += ['ROUND']
    if macros.get('LJ_ARCH_PPC32ON64', 0) == '1': dasm_defs += ['GPR64']
    if ctx.env.DEST_OS == 'win32' or ctx.env.DEST_OS == 'win64':
        dasm_defs += ['WIN']
    # ios, ps3 checks removed

    dasm_arch = None
    if macros.get('LJ_TARGET_X86', None):        ljarch = dasm_arch = 'x86'
    if macros.get('LJ_TARGET_X64', None):
        _ =                                      ljarch = dasm_arch = 'x64'
        if macros.get('LJ_FR2', 0) != '1':                dasm_arch = 'x86'
    if macros.get('LJ_TARGET_ARM', None):        ljarch = dasm_arch = 'arm'
    if macros.get('LJ_TARGET_ARM64', None):      ljarch = dasm_arch = 'arm64'
    if macros.get('LJ_TARGET_PPC', None):        ljarch = dasm_arch = 'ppc'
    if macros.get('LJ_TARGET_MIPS', None):
        if macros.get('LJ_TARGET_MIPS64', None): ljarch = dasm_arch = 'mips64'
        else:                                    ljarch = dasm_arch = 'mips'
    if not dasm_arch:
        ctx.end_msg(False)
        ctx.fatal('Unsupported ljx architecture')

    ctx.env.DASM_ARCH = dasm_arch
    ctx.env.DASM_DEFINE_ST = ['-D']
    ctx.env.DASM_DEFINES = dasm_defs
    ctx.end_msg('arch: %s/%s, dasm defines: %s' % (ljarch, dasm_arch, ' '.join(dasm_defs)))

    # buildvm flags
    dest_os = ctx.env.DEST_OS
    ctx.setenv(host_variant)
    ctx.env.append_value('CFLAGS_BUILDVM'+suf, '-m' + macros['LJ_ARCH_BITS'])
    ctx.env.append_value('LINKFLAGS_BUILDVM'+suf, '-m' + macros['LJ_ARCH_BITS'])

    # os
    if dest_os == 'win32' or dest_os == 'win64':
        ctx.env.append_value('CFLAGS_BUILDVM'+suf, '-malign-double')
        ctx.env.append_value('DEFINES_BUILDVM'+suf, 'LUAJIT_OS=LUAJIT_OS_WINDOWS')
    elif dest_os == 'linux':
        ctx.env.append_value('DEFINES_BUILDVM'+suf, 'LUAJIT_OS=LUAJIT_OS_LINUX')
    elif dest_os == 'darwin':
        ctx.env.append_value('DEFINES_BUILDVM'+suf, 'LUAJIT_OS=LUAJIT_OS_OSX')
    else:
        ctx.env.append_value('DEFINES_BUILDVM'+suf, 'LUAJIT_OS=LUAJIT_OS_OTHER')

    # architecture specific shit
    if macros.get('LJ_TARGET_PPC', None):
        if macros.get('LJ_LE', 0) == '1':
            ctx.env.append_value('DEFINES_BUILDVM'+suf, 'LJ_ARCH_ENDIAN=LUAJIT_LE')
        else:
            ctx.env.append_value('DEFINES_BUILDVM'+suf, 'LJ_ARCH_ENDIAN=LUAJIT_BE')
    if macros.get('LJ_TARGET_MIPS', None) and macros.get('MIPSEL', None):
        ctx.env.append_value('DEFINES_BUILDVM'+suf, '__MIPSEL__=1')

    ctx.env.append_value('DEFINES_BUILDVM'+suf, [
        'LUAJIT_TARGET=LUAJIT_ARCH_'+ljarch,
        'LJ_ARCH_HASFPU='+macros.get('LJ_ARCH_HASFPU', 0),
        'LJ_ABI_SOFTFP='+macros.get('LJ_ABI_SOFTFP', 0),
    ])
    if macros.get('LJ_NO_UNWIND', 0) == '1':
        ctx.env.append_value('DEFINES_BUILDVM'+suf, 'LUAJIT_NO_UNWIND=1')

    ctx.setenv(variant)

    ctx.env.append_value('DEFINES_LJX',
                         ['LJ_ABIVER=51', 'LUAJIT_ENABLE_LUA53COMPAT'])
    if not ctx.options.release:
        ctx.env.append_value('DEFINES_LJX', 'LUA_USE_APICHECK')

def build(ctx):
    host_env = ctx.all_envs[ctx.variant + '_host']

    invalid_files = [
        'ljx/src/host/buildvm_arch.h',
        'ljx/src/lj_bcdef.h',
        'ljx/src/lj_ffdef.h',
        'ljx/src/lj_libdef.h',
        'ljx/src/lj_recdef.h',
        'ljx/src/lj_folddef.h',
    ]
    for f in invalid_files:
        nd = ctx.path.find_node(f)
        if nd:
            ctx.fatal('%s exists, run `make clean` in ext/ljx' % nd.abspath())

    minilua = False
    if not ctx.env.LUA:
        ctx.program(source = 'ljx/src/host/minilua.c',
                    env    = host_env.derive(),
                    uselib = 'M',
                    target = 'minilua')

        tg = ctx.get_tgen_by_name('minilua')
        tg.post()
        ctx.env.LUA = tg.link_task.outputs[0].abspath()
        minilua = True

    if ctx.env.LJX_CROSS:
        old_env = ctx.env
        ctx.env = host_env
        ctx.env.LUA = old_env.LUA
        build_ljx(ctx, minilua, host_env, 'host/', '_HOST')
        ctx.env = old_env

    build_ljx(ctx, minilua, host_env, '', '')

def build_ljx(ctx, minilua, host_env, pref, suf):
    src = ['ljx/dynasm/dynasm.lua', 'ljx/src/vm_%s.dasc' % ctx.env.DASM_ARCH]
    if minilua: src += ['minilua']
    ctx(rule           = '${LUA} ${SRC[0].abspath()} ${DASM_DEFINE_ST:DASM_DEFINES} -o ${TGT} ${SRC[1].abspath()}',
        source         = src,
        shell          = False,
        update_outputs = True,
        target         = pref+'buildvm_arch.h')

    src = [
        'ljx/src/host/buildvm_asm.c',
        'ljx/src/host/buildvm.c',
        'ljx/src/host/buildvm_fold.c',
        'ljx/src/host/buildvm_lib.c',
        'ljx/src/host/buildvm_peobj.c',
    ]
    tg = ctx.program(source   = src,
                     env      = host_env.derive(),
                     includes = pref+'. ljx/src',
                     defines  = 'LUAJIT_ENABLE_LUA53COMPAT',
                     uselib   = 'BUILDVM'+suf,
                     target   = pref+'buildvm')
    tg.post()
    buildvm = tg.link_task.outputs[0].abspath()

    tgt = pref+'lj_vm.s'
    if ctx.env.DEST_OS == 'win32' or ctx.env.DEST_OS == 'win64':
        mode = 'peobj'
        tgt  = pref+'lj_vm.obj'
    elif ctx.env.DEST_OS == 'darwin':
        mode = 'machasm'
    else:
        mode = 'elfasm'

    ctx(rule           = '%s -m %s -o ${TGT}' % (buildvm, mode),
        shell          = False,
        update_outputs = True,
        deps           = pref+'buildvm',
        target         = tgt)

    src = [
        'ljx/src/lib_base.c',
        'ljx/src/lib_math.c',
        'ljx/src/lib_bit.c',
        'ljx/src/lib_string.c',
        'ljx/src/lib_utf8.c',
        'ljx/src/lib_table.c',
        'ljx/src/lib_io.c',
        'ljx/src/lib_os.c',
        'ljx/src/lib_package.c',
        'ljx/src/lib_debug.c',
        'ljx/src/lib_jit.c',
        'ljx/src/lib_ffi.c',
    ]
    for mode in ['bcdef', 'ffdef', 'libdef', 'recdef']:
        ctx(rule           = '%s -m %s -o ${TGT} ${SRC}' % (buildvm, mode),
            shell          = False,
            update_outputs = True,
            source         = src,
            deps           = pref+'buildvm',
            target         = '%slj_%s.h' % (pref, mode))
    ctx(rule           = '%s -m folddef -o ${TGT} ${SRC}' % buildvm,
        shell          = False,
        update_outputs = True,
        source         = 'ljx/src/lj_opt_fold.c',
        deps           = pref+'buildvm',
        target         = pref+'lj_folddef.h')
    # only needed by luajit-ljx?
    ctx(rule           = '%s -m vmdef -o ${TGT} ${SRC}' % buildvm,
        shell          = False,
        update_outputs = True,
        source         = src,
        deps           = pref+'buildvm',
        target         = pref+'jit/vmdef.lua')


    ver = 'LJX_VERSION="%s"' % ctx.path.find_node('ljx/.version').read().strip()
    ctx.stlib(source          = ['ljx/src/ljamalg.c', tgt],
              includes        = pref+'.',
              export_includes = 'ljx/src',
              defines         = ver,
              uselib          = 'EXT',
              use             = 'LJX DL M',
              target          = pref+'ljx')

    # todo: maybe integrate into stcm-editor
    # only really needed for host
    ctx.program(source  = 'ljx/src/luajit.c',
                use     = pref+'ljx',
                uselib  = 'READLINE',
                defines = [ ver, 'LUA_CREDITS=""' ],
                target  = pref+'luajit-ljx')

from waflib.TaskGen import after_method, feature, extension
from waflib.Task import Task
class copy(Task):
    run_str = 'cp ${SRC} ${TGT}'

@extension('.o', '.obj')
def add_those_o_files(self, node):
    try:
        self.o_files.append(node)
    except AttributeError:
        self.o_files = [node]

@feature('c', 'cxx', 'd', 'fc', 'asm')
@after_method('apply_link')
def add_o(self):
    if getattr(self, 'o_files', None):
        self.link_task.inputs += self.o_files
